<!DOCTYPE html>
<html lang="eng">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>L. Szameitat</title>
    <link rel="stylesheet" href="css/global.css" />
    <link rel="stylesheet" href="css/style.css" />
    <link rel="stylesheet" href="css/codes.css" />
    <link
      rel="stylesheet"
      href="css/media1061.css"
      media="(max-width:1061px)"
    />
    <link rel="stylesheet" href="css/media767.css" media="(max-width:767px)" />

    <link rel="icon" href="assets/ico/favicon.png" type="image/x-icon" />
    <link
      rel="shortcut icon"
      href="assets/ico/favicon.png"
      type="image/x-icon"
    />

    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Roboto:wght@300&display=swap"
      rel="stylesheet"
    />

    <link
      rel="stylesheet"
      href="https://use.fontawesome.com/releases/v5.15.4/css/solid.css"
      integrity="sha384-Tv5i09RULyHKMwX0E8wJUqSOaXlyu3SQxORObAI08iUwIalMmN5L6AvlPX2LMoSE"
      crossorigin="anonymous"
    />
    <link
      rel="stylesheet"
      href="https://use.fontawesome.com/releases/v5.15.4/css/fontawesome.css"
      integrity="sha384-jLKHWM3JRmfMU0A5x5AkjWkw/EYfGUAGagvnfryNV3F9VqM98XiIH7VBGVoxVSc7"
      crossorigin="anonymous"
    />
  </head>
  <body>
    <header class="caixa-cabecalho">
      <h1 class="nome-cabecalho-mobile">PhD Luizemara Szameitat</h1>

      <nav>
        <ul>
          <li class="item-cabecalho">
            <a href="index.html">Home</a>
          </li>
          <li class="item-cabecalho menu-filhos" id="clickable-link">
            <a href="#">Work</a>
            <!-- Menu filhos -->
            <ul class="menu-filhos">
              <li class="item-cabecalho">
                <a href="pub.html">Articles</a>
              </li>

              <li class="item-cabecalho">
                <a href="codes.html">Coding</a>
              </li>

              <li class="item-cabecalho">
                <a href="exerc.html">Exercises</a>
              </li>

              <li class="item-cabecalho">
                <a href="http://lattes.cnpq.br/4322898960715686" target="_blank"
                  >CNPq Lattes</a
                >
              </li>
            </ul>
          </li>
        </ul>
      </nav>
    </header>
    <section>
      <div class="codes-cabecalho">
        <h1>Codes for Education</h1>
        <h2>
          Computational resources for treating magnetometric and gravimetric in
          Geophysical lectures
        </h2>

        <p class="referencia-texto">
          Szameitat, L.S.A., Bongiolo, A.B.S. (2024) Recursos computacionais
          para tratamento de dados magnetométricos e gravimétricos em sala de
          aula. Boletim Paranaense de Geociências, v. 82, n. 1.
        </p>
        <p class="codes-descricao">
          Abstract: The team at the Laboratory for Applied Geophysics Research
          (LPGA-UFPR) has been dedicated to developing research work in teaching
          and promoting geophysics, raising awareness and understanding of
          geophysical methods within the university and for the external public.
          In line with this effort, the authors have prepared a collection of
          Python scripts for processing gravimetric and magnetometric data using
          basic techniques: horizontal and vertical derivatives, horizontal
          gradient, reduction to the pole, analytical signal amplitude, and
          Bouguer anomaly estimation. To facilitate classroom use, the
          algorithms have been formatted as Jupyter Notebooks and designed for
          use in the Google Colaboratory programming environment. The
          geophysical data transformations were adapted from classic functions
          in the literature and also employed existing libraries in the same
          language. The function algorithms are included in this material, and
          the complete Python notebook programs are available and being updated
          in a public GitHub repository. As a result, this work provides an
          accessible tool for geoscience students in the analysis of potential
          field data.
        </p>
        <div class="hero-botoes" left="0">
          <div class="botao-github">
            <a href="https://github.com/lszam/ensino" target="_blank"
              >GitHub project
            </a>
          </div>
          <div class="botao-github">
            <a
              href="https://revistas.ufpr.br/geociencias/article/view/91973"
              target="_blank"
            >
              Article
            </a>
          </div>
        </div>

        <h3>References:</h3>
        <p class="referencia-texto">
          Blakely, R. J. (1996). Potential theory in gravity and magnetic
          applications. Cambridge University Press.
        </p>
        <p class="referencia-texto">
          Uieda, L., Oliveira Jr, V. C., & Barbosa, V. C. (2013). Modeling the
          earth with Fatiando a Terra. In Proceedings of the 12th Python in
          Science Conference (pp. 96-103).<a
            href="https://pdfs.semanticscholar.org/ba6d/b75613a2daf1b9f5bb19602e67d5a281b124.pdf"
            >[link]</a
          >
        </p>
      </div>
      <div class="letscode">
        <div class="caixa-icone-code">
          <img src="assets/ico/woman-icon.png" />
        </div>
        <h2>Let's code!</h2>
      </div>

      <div class="codes-conteudo">
        <div class="container-jupyter">
          <div class="links">
            <a
              href="#"
              onclick="loadPage('https://nbviewer.jupyter.org/github/lszam/ensino/blob/main/geof_mag/geof_mag_rtp-blakely_magsitio.ipynb')"
              ><h3>Jupyter Notebook - Magnetometria - Redução ao Polo</h3></a
            >
            <a
              href="#"
              onclick="loadPage('https://nbviewer.jupyter.org/github/lszam/ensino/blob/main/geof_grav/geof_grav_boug.ipynb')"
              ><h3>Jupyter Notebook - Gravimetria - Anomalia Bouguer</h3></a
            >
            <a
              href="#"
              onclick="loadPage('https://nbviewer.jupyter.org/github/lszam/ensino/blob/main/geof_filtros/geof_gradientehoriz.ipynb')"
              ><h3>
                Jupyter Notebook - Técnicas de realce - Gradiente Horizontal
                Total
              </h3></a
            >

            <a
              href="#"
              onclick="loadPage('https://nbviewer.jupyter.org/github/lszam/cprm-nfis/blob/main/ls_jupyter/ls_magnetic_der_asa_asa2pvd_signum.ipynb')"
              ><h3>
                Jupyter Notebook - ASA, PDZASA2, e binarização de anomalia
              </h3></a
            >
          </div>

          <div class="iframe-container">
            <iframe id="iframe" src=""></iframe>
          </div>
        </div>

        <div class="container-codes">
          <!-- Lista de Codigos -->

          <!-- Gradiente Horizontal -->
          <div class="codes-codes">
            <h3>
              <img src="assets/logo/logo-py.png" alt="logo-py" height="14px" />
              GradHoriz()
            </h3>
            <p class="codes-descricao">Total horizontal gradient</p>
            <div class="code">
              <p>
                <a href="#" id="copyToClipboard1" class="fa fa-paste"></a>
              </p>
              <pre>
                <code>
  def GradHoriz(vetor, nx, ny, dx, dy):
    '''
    Parametros
    ----------
          vetor (1d array): 
            array de uma dimensão contendo o campo total
          nx, ny (int):
            numero de amostras em x e y
          dx, dy (int):
            distancia entre amostras em x e y
                '''
    dx2 = 2*dx
    dy2 = 2*dy
    vetor_GH = np.ones(nx*ny)
    for j in range(1, ny+1):
      jm1 = j - 1
      if jm1 < 1: #condição de borda
        jm1 = 1
      jp1 = j + 1
      if jp1 > ny: #condição de borda
        jp1 = ny
      for i in range(1, nx+1):
        im1 = i - 1
        if im1 < 1: #condição de borda
          im1 = 1
        ip1 = i + 1
        if ip1 > nx: #condição de borda
          ip1 = nx
        #index(i,j,nx) = (j-1) * nx + i #função index em Blakely (1996)
        indexip1 = (jp1-1) * nx + (i-1)
        indexim1 = (j-1) * nx + (im1-1)
        indexjp1 = (jp1-1) * nx + (i-1)
        indexjm1 = (j-2) * nx + (i-1)
        #Análise de valores no espaço
        dfdx = (vetor[indexip1]-vetor[indexim1]) / dx2
        dfdy = (vetor[indexjp1]-vetor[indexjm1]) / dy2
        ij = (j-1) * nx + (i-1)
        vetor_GH[ij] = sqrt(dfdx**2+dfdy**2)
                
    return vetor_GH
                </code>
              </pre>
            </div>
          </div>
          <!-- Fim do Codigo 1 -->

          <!-- Newvec -->
          <div class="codes-codes">
            <h3>
              <img src="assets/logo/logo-py.png" alt="logo-py" height="14px" />
              NewVec()
            </h3>
            <p class="codes-descricao">
              Reduction to the pole. Recquires DirCos() and Kvalue()
            </p>
            <div class="code">
              <p>
                <a href="#" id="copyToClipboard3" class="fa fa-paste"></a>
              </p>
              <pre>
            <code>
def NewVec(grid, nx, ny, dx, dy, fi1, fd1, mi1, md1, fi2, fd2, mi2, md2):
  '''
  NewVec(grid, nx, ny, dx, dy, fi1, fd1, mi1, md1, fi2, fd2, mi2, md2)
  Objetivo: simular mudanças na direção de magnetização
  Para redução ao polo, deve-se usar mi2 = fi2 = 90
  Parameters
  ----------
  grid - array de duas dimensões contendo o campo total
  nx, ny (int):
  numero de amostras em x e y
  dx, dy (int):
  distancia entre amostras em x e y
  mi1, md1 - (graus):
    inclinacao e declinacao da magnetizacao
  fi1, fd1 - (graus):
    Magnetizacao do campo geomagnetico atual (inclinacao, declinacao)
  mi2, md2 - (graus):
    Nova direção de magnetizacao (inclinacao, declinacao)
  fi2, fd2 - (graus):
    Nova magnetizacao do campo geomagnetico (inclinacao, declinacao)
  '''
          
  dkx = 2. * np.pi / (nx * dx)
  dky = 2. * np.pi / (ny * dy)
          
  #Cossenos direcionais
  mx1, my1, mz1 = DirCos(mi1, md1, 0.) # i,d do corpo, magnetização inicial
  fx1, fy1, fz1 = DirCos(fi1, fd1, 0.) # i,d do campo, inicial
  mx2, my2, mz2 = DirCos(mi2, md2, 0.) # i,d do corpo, final
  fx2, fy2, fz2 = DirCos(fi2, fd2, 0.) # i,d do campo, final
          
  #Transformada de Fourier usando scipy
  gridfft = scipy.fftpack.fft2(grid) # fft2 - matriz 2D
  gridfft = np.reshape(gridfft, nx*ny) # muda a matriz fft para forma 1D
          
  #Filtro de fase
    for j in range (1, nx+1):
        for i in range (1, ny+1):
            ij = (j-1) * ny + i
            if ij == 1:
                cphase = 0.0
            else:
                kx, ky = Kvalue(i, j, nx, ny, dkx, dky) # ** funcao Kvalue
                k = sqrt(kx**2 + ky**2)
                thetam1 = complex(mz1, (kx*mx1 + ky*my1) / k)
                thetaf1 = complex(fz1, (kx*fx1 + ky*fy1) / k)
                thetam2 = complex(mz2, (kx*mx2 + ky*my2) / k)
                thetaf2 = complex(fz2, (kx*fx2 + ky*fy2) / k)
                cphase = thetam2 * thetaf2 / (thetam1 * thetaf1)
          
            # Filtra cada item do grid
            gridfft[ij-1] = gridfft[ij-1]*cphase
          
    #Fourier
    gridfft = np.reshape(gridfft, (ny, nx)) # retorna para formato 2D
    gridifft = scipy.fftpack.ifft2(gridfft)
    grid = gridifft.real #usamos apenas a parte real
          
    return grid
              </code>
            </pre>
            </div>
          </div>
          <!-- Fim do Codigo 3 -->

          <!-- DirCos -->
          <div class="codes-codes">
            <h3>
              <img src="assets/logo/logo-py.png" alt="logo-py" height="14px" />
              DirCos()
            </h3>
            <p class="codes-descricao">Direcional cosine</p>
            <div class="code">
              <p>
                <a href="#" id="copyToClipboard3" class="fa fa-paste"></a>
              </p>
              <pre>        
    <code>
def DirCos(i, d, az):
  '''
  Parametros
  ----------
  i - inclinacao
  d - declinacao
  az - azimute
  '''
  a = cos(radians(i))*cos(radians(d)-radians(az))
  b = cos(radians(i))*sin(radians(d)-radians(az))
  c = sin(radians(i))
  return a, b, c

      </code>
    </pre>
            </div>
          </div>
          <!-- Fim do Codigo DirCos -->

          <!-- Kvalue -->
          <div class="codes-codes">
            <h3>
              <img src="assets/logo/logo-py.png" alt="logo-py" height="14px" />
              Kvalue()
            </h3>
            <p class="codes-descricao">as part of some Blakely's functions</p>
            <div class="code">
              <p>
                <a href="#" id="copyToClipboard2" class="fa fa-paste"></a>
              </p>
              <pre>
                      <code>
        def Kvalue(i, j, nx, ny, dkx, dky):
          '''
          Parametros
          ----------
          i, j(int):
            posicoes, ou indices de varredura
          nx, ny (int):
            número de amostras em x e y
          dkx, dky (int):
            distância em x e y em radianos
          '''
          nyqx = nx / 2 + 1
          nyqy = ny / 2 + 1
          kx = float()
          ky = float()
          if j <= nyqx:
            kx = (j-1) * dkx
          else:
            kx = (j-nx-1) * dkx
          if I <= nyqy:
            ky = (i-1) * dky
          else:
            ky = (i-ny-1) * dky
          return kx, ky
                        </code>
                      </pre>
            </div>
          </div>
          <!-- Fim do Kvalue -->
        </div>
      </div>

      <!-- Fim do container-codes -->
    </section>

    <script>
      function loadPage(url) {
        document.getElementById("iframe").src = url;
      }
    </script>

    <script>
      document
        .getElementById("copyToClipboard1")
        .addEventListener("click", function () {
          var codeElement = document.querySelector(".code code");
          var textToCopy = codeElement.innerText;

          navigator.clipboard
            .writeText(textToCopy)
            .then(function () {
              alert("Code copied to clipboard!");
            })
            .catch(function (err) {
              console.error("Unable to copy code: ", err);
              alert("Failed to copy code to clipboard.");
            });
        });

      document
        .getElementById("copyToClipboard2")
        .addEventListener("click", function () {
          var codeElement = document.querySelectorAll(".code code")[1];
          var textToCopy = codeElement.innerText;

          navigator.clipboard
            .writeText(textToCopy)
            .then(function () {
              alert("Code copied to clipboard!");
            })
            .catch(function (err) {
              console.error("Unable to copy code: ", err);
              alert("Failed to copy code to clipboard.");
            });
        });

      document
        .getElementById("copyToClipboard3")
        .addEventListener("click", function () {
          var codeElement = document.querySelectorAll(".code code")[1];
          var textToCopy = codeElement.innerText;

          navigator.clipboard
            .writeText(textToCopy)
            .then(function () {
              alert("Code copied to clipboard!");
            })
            .catch(function (err) {
              console.error("Unable to copy code: ", err);
              alert("Failed to copy code to clipboard.");
            });
        });
    </script>
  </body>
</html>
